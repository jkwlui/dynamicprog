1. Base cases:
""
""
Sum of squares of slack space: 0

"The cat in the hat."
"The cat in the hat."

Sum of squares of slack space:

Small cases:
"This little piggy went to market.
This little piggy stayed home.
This little piggy had roast beef.
This little piggy had none.
And this little piggy cried wee wee wee all the way home."

Sum of squares of slack space:

"This little piggy went to market.
This little piggy stayed home. This
little piggy had roast beef. This
little piggy had none. And this little
piggy cried wee wee wee all the way home."

Sum of squares of slack space:

Substantial case:
"Call me Ishmael.
Some years ago,
never mind how long precisely,
having little or no money in my purse,
and nothing particular to interest me on shore,
I thought I would sail about a little
and see the watery part of the world."

Sum of squares of slack space:

"Call me Ishmael. Some years ago, never
mind how long precisely, having little
or no money in my purse, and nothing
particular to interest me on shore, I
thought I would sail about a little
and see the watery part of the world."

Sum of squares of slack space:

2. Mathematical recurrence for cost of sum of
squared slacks in optimal solution:

Define OPT(k) to be the optimum solution (minimize slack spaces for all lines) for
lines containing words w(1) up to w(k).

Define S(i,k) to be the slack space(s) of a line that contains the words w(i) up to w(k).
Define S(i,k) := infinity if such line exceeds the maximum number of words allowed for a line.

Then OPT(k) = min_(i<=i<=k) [(S^2(i,k)) + OPT(k-1)]
Define OPT(0) = 0    // optimal solution for the set of 0 words is 0. (no slack space for no words)

That is, find the minimum squared cost (slack space) by iteratively fitting more words into
a line and finding the optimal solution of the remaining words.

Therefore, the optimal solution of w(1)..w(n) is computed by finding OPT(n) - building up
from OPT(0), OPT(1), .. , OPT(n)



3. Memoized version runtime: Θ(n^2)

By storing OPT(0), OPT(1), .. , OPT(n), we just need to computer each OPT(k) once,
so there are n iterations of computing the optimum sub-solutions.

Each OPT(k) will need to compute S^2(i,k) from i=0 to k, assuming it takes O(1) time
to compute each, it would take Θ(n) time. Finding the minimum of these values are
just O(n) time (could do better - using BST, but previous computation dominates), thus
the total time would be Θ(n^2) time.


4. Java

5. L = max(line.length);

FindMinSlack(Text){

SquaresOfSlacksOfAllLines = []

  for every word in Text {
    if sum(characters in word + 1) <= L {
      LeftHandSide =
      RightHandSide =
      slack= LeftHandSide - RightHandSide
      }
    min(sum of squares of slacks of all lines)
    }

6.

7.

8.

9.
